% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NDepositsPmf.R
\name{NDepositsPmf}
\alias{NDepositsPmf}
\title{Construct the pmf for the number of undiscovered deposits}
\usage{
NDepositsPmf(type, pmf.args, description = "")
}
\arguments{
\item{type}{The type of pmf (See Details).}

\item{pmf.args}{The arguments characterizing the specified type
(See Details).}

\item{description}{A short description of the pmf.}
}
\value{
If the input arguments have an error, the R-value NULL is returned.
Otherwise, a list with the following components is returned.

\item{Type}{Input argument type}

\item{pmf.args}{Input argument pmf.args}

\item{description}{Input argument description}

\item{call}{Function call}

\item{probs}{Vector containing just the non-zero probabilities
in the pmf.}

\item{nDeposits}{Vector containing the number of undiscovered
deposits that are associated with the non-zero probabilities in the pmf.
The size of vector nDeposits is equal to the size of vector probs.}

\item{specifiedAccdf}{If th3 type is "Mark3" or "Mark4", then
this entry is a vector containing probabilities from the alternative
complementary cumulative distribution function. These probabilites are
associated with the thresholds, which are specified in pmf.arg. Otherwise,
this entry is NULL.}

\item{theMean}{The expected value (mean) of the number of
undiscovered deposits within the permissive tract. The number might differ
slightly from the input specification.}

\item{theVar}{The variance of the number of undiscovered deposits
within the permissive tract.}

\item{accdf}{The alternative complementary cumulative distribution
function for the pmf. Although it is calculated for all types of pmfs,
it is useful only for the "Mark3" and "Mark4" types.}

\item{entropy}{The information entropy, which is calculated with
the natural logarithm.}
}
\description{
Construct the probability mass function for the number of
undiscovered deposits within the permissive tract
}
\details{
The type is a character string and must be one of "Mark3", "Mark4",
"UserSpecified", "Poisson", "NegBinomial", or "Debug". Each type has
different arguments, which are specified in pmf.args. The arguments for
each type are described below.

\emph{Mark3}

List pmf.args has one element, which is named "thresholds". Thresholds
is a vector of integers. The meaning of each element in the vector
is described in this table. To make the table concise,
threshold[1] is represented by t[1], and so on. The size of vector thresholds
can be only 3, 5, 7 or 9.

\tabular{lllll}{
Element \tab Size = 3             \tab Size = 5              \tab Size = 7               \tab Size = 9                \cr
t[1]    \tab P( N >= t[1] ) = 0.9 \tab P( N >= t[1] ) = 0.9  \tab P( N >= t[1] ) = 0.9   \tab P( N >= t[1] ) = 0.9    \cr
t[2]    \tab P( N >= t[2] ) = 0.5 \tab P( N >= t[2] ) = 0.5  \tab P( N >= t[2] ) = 0.5   \tab P( N >= t[2] ) = 0.5    \cr
t[3]    \tab P( N >= t[3] ) = 0.1 \tab P( N >= t[3] ) = 0.1  \tab P( N >= t[3] ) = 0.1   \tab P( N >= t[3] ) = 0.1    \cr
t[4]    \tab ---                  \tab P( N >= t[4] ) = 0.05 \tab P( N >= t[4] ) = 0.05  \tab P( N >= t[4] ) = 0.05   \cr
t[5]    \tab ---                  \tab P( N >= t[5] ) = 0.01 \tab P( N >= t[5] ) = 0.01  \tab P( N >= t[5] ) = 0.01   \cr
t[6]    \tab ---                  \tab ---                   \tab P( N >= t[6] ) = 0.005 \tab P( N >= t[6] ) = 0.005  \cr
t[7]    \tab ---                  \tab ---                   \tab P( N >= t[7] ) = 0.001 \tab P( N >= t[7] ) = 0.001  \cr
t[8]    \tab ---                  \tab ---                   \tab ---                    \tab P( N >= t[8] ) = 0.0005 \cr
t[9]    \tab ---                  \tab ---                   \tab ---                    \tab P( N >= t[9] ) = 0.0001
}

The expression P( N >= t[1] ) = 0.9 means that the probability that the
number of the deposits (N)
will be at least t[1] is 0.9. That is, there is a 0.9 probability
(90 percent chance) of finding t[1] or more
deposits. The elements of t (thresholds) must be nondecreasing. For example,
if the size is 3, then t[1] <= t[2] <= t[3]. Although it seems that the
elements of t (thresholds) should
be strictly increasing, this is not required by the algorithm implemented
in Fortran subroutine Mark3Pmf

If t[1] is 0, then, according to the previous definition, P( N >= 0 ) = 0.9.
Of course,
this is wrong because P( N >= 0 ) = 1. To address this problem, the
algorithm is implemented such that P( N >= 1 ) < 0.9.

The p quantile of the cumulative distribution function F is defined as
the smallest x such that F(x) >= p. (DeGroot and Schverish, 2002, p. 115).
That is, the p quantile is the smallest x such that P( X <= x ) >= p where
X is a random variable.
This definition obviously differs from that for thresholds. Hence, quantiles
are not thresholds.

The probabilities in each column of the above table appear to constitute
a complementary cumulative
distribution function (ccdf). However, a ccdf G is defined as
G(x) = P( X > x). (See the wikipedia reference.)
Because the table lists P( X >= x ), the probabilities in each column do
not constitute a ccdf. To
prevent any confusion, these probabilites are called "alternative
complementary cumulative distribution function,"
which will be abbreviated "accdf".

Fortran subroutine Mark3Pmf calculates a pmf such that its aacdf
approximates (but rarely equals) the aacdf that is specified with
the thresholds.
This subroutine was extracted from program Mark3B (Root and others, 1992;
Root and others, 1998) and then compiled as a direct link library.

\emph{Mark4}

List pmf.args has two elements, which are named "thresholds" and
"maxNumberOfDeposits". Thresholds was described in the previous section.
Variable maxNumberOfDeposits is an integer; it must be greater than or
equal to the last element in thresholds.

Fortran subroutine Mark4Pmf calculates a pmf such that its aacdf
equals exactly the aacdf that is specified with the thresholds.
The algorithm was developed and implemented by Jeffery D. Phillips.

\emph{UserSpecified}

List pmf.args has two elements, which are named "anchorPts" and
"relProbabilities". anchorPts is an integer vector, and relProbabilities is
a real vector with the same size as anchorPts.

A common way to use this function is to have three elements in vector
anchorPts and
three elements in vector relProbabilities. Regarding vector anchorPts,
the first element
is the minimum number of deposits in the tract, the second is the mode,
and the third is the maximum
number of deposits in the tract. The first element must be greater than
or equal to 0, and all elements
must be in strictly ascending order. That is,
0 <= anchorPts[1] < anchorPts[2] < anchorPts[3].
Regarding vector relProbabilities, the first, second, and third elements
are the relative probabilities
associated with anchorPts[1], anchorPts[2], and anchorPts[3]. The relative
probability is any postive,
real-valued number. Because anchorPts[2] is the mode, relProbabilities[2]
must be
greater than relProbabilities[1] and relProbabilities[3]. The sum of the
elements in relProbabilities
is not required to be 1.

The relative probabilites between anchorPts[1] and anchorPts[3] are
calculated by linearly interpolating the
elements of relProbabilities. Then these interpolated, relative
probabilities are scaled, so that their sum is 1.

This function is very flexibile: The minimum number of elements in vector
anchorPts is 2; there is no maximum.
(Vector relProbabilities and vector anchorPts must have the same length.)
If this flexibility is exploited, then
the user should carefully check the calculated probability mass function.

\emph{Poisson}

List pmf.args has one element, which is named "theMean". theMean is
real-valued and is the mean of the Poisson pmf.

For the Poisson pmf, the random variable that represents the number of
undiscovered deposits extends from 0 to infinity. Of course, the Monte Carlo
simulation cannot be performed for an infinite range. When the number of
deposits is far from the mean, the probabilities are so small
that they have no practical effect on the simulation results.
The range associated with these small probabilites is delimited
by a lower bound and an upper bound, which are calulated from
variable relProbabilityThreshold. To understand the meaning of this variable,
assume that it is 0.001. The lower bound is the quantile for which
the probability in the left tail is 0.001 times the probability of the
mode of the pmf. Similarly, the right bound is the quantile for which
the probability in the right tail is 0.001 times the probability of the
mode of the pmf.
The pmf is truncated at the lower and the upper bounds, and then rescaled
so that the sum of the probabilities is 1. This rescaling changes the
mean of the pmf slightly.
Usually, the mean of the pmf is small, so that the lower bound is 0.
In this (common) case, the lower bound does not affect
the truncation of the Poisson pmf.

Variable relProbabilityThreshold has a default value, but it can be changed
by specifyting the new value in list pmf.args.

\emph{NegBinomial}

List pmf.args has two elements, which are named "theMean" and "theStdDev".
Both theMean and theStdDev are real-valued. theMean and theStdDev are
the mean and the standard deviation of the negative binomial pmf. theMean
must be less than the square of variable theStdDev.

For the negative binomial pmf, the random variable that represents the
number of
undiscovered deposits extends from 0 to infinity. Of course, the Monte Carlo
simulation cannot be performed for an infinity range. The procedure that
solves for this problem is described in section for the Poisson pmf.

\emph{Debug}

List pmf.args has two elements, which are named "nDeposits" and
"relProbabilities". nDeposits is an integer vector, and relProbabilities is
a real vector with the same size as anchorPts.

Regarding vector nDeposits, all elements must be in strictly ascending order.
That is,
0 <= nDeposits[1] < nDeposits[2] < nDeposits[3] and so on. Regarding
vector relProbabilities, the elements are postive,
real-valued numbers. The sum of the elements in relProbabilities is
not required to be 1. Vector nDeposits
and vector relProbabilites must have the same length.

Here are three examples: If nDeposits = c(1) and relProbabilities=c(1),
then the probability mass function will be 1
when nDeposits is 1. If nDeposits = c(10) and relProbabilities=c(1),
then the probability mass function will be 1
when nDeposits is 10. If nDeposits = c(0,1) and relProbabilities=c(1.0,0.5),
then the probability mass function will
be 0.667 and 0.333 when nDeposits is 0 and 1, respectively.
}
\examples{
# Mark3 pmf
nDepositsPmf1 <- NDepositsPmf( "Mark3", list(thresholds=c(1,7,20)),
"Test Mark3" )
plot( nDepositsPmf1 )

# Mark4 pmf
nDepositsPmf2 <- NDepositsPmf( "Mark4",
list(thresholds=c(1,7,20),maxNumberOfDeposits=23), "Test Mark4" )
plot( nDepositsPmf2 )

# User specified pmf
nDepositsPmf3 <- NDepositsPmf( "UserSpecified",
list(anchorPts=c(1,4,10),relProbabilities=c(1,4,1)),
"Test UserSpecified" )
plot( nDepositsPmf3 )

# Poisson pmf
nDepositsPmf4 <- NDepositsPmf( "Poisson", list(theMean=5), "Test Poisson" )
plot( nDepositsPmf4 )

# Negative binomial pmf
nDepositsPmf5 <- NDepositsPmf( "NegBinomial", list(theMean=5,theStdDev=4),
"Test Negative binomial" )
plot( nDepositsPmf5 )

# Debug pmf
nDepositsPmf6 <- NDepositsPmf( "Debug", list(nDeposits=1,relProbabilities=1),
"Test Debug 1" )
plot( nDepositsPmf6 )

# Debug pmf
nDepositsPmf7 <- NDepositsPmf( "Debug",
list(nDeposits=c(2,3),relProbabilities=c(0.3,0.7)), "Test Debug 2" )
plot( nDepositsPmf7 )

}
\references{
DeGroot, M.H., and Schervish, M.J., 2002, Probability and statistics: Addison-Wesley.

Root, D.H., Menzie, W.D., and Scott, W.A., 1992, Computer Monte Carlo simulation in quantitative
resource estimation: Nonrenewable resources, v. 1, no. 2, p. 125-138.

Root, D.H., Scott, W.A., Jr., Schruben, P.G., 1998, MARK3B Resource assessment program for Macintosh:
U.S. Geological Survey, Open-file report 98-356.

http://en.wikipedia.org/wiki/Cumulative_distribution_function
}

